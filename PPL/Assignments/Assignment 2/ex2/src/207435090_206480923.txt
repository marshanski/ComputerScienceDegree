;---------------------------------------------------------------------------------
;Signature      : take(lst,pos)
;Type           : [(int->Boolean)*list(T1)-> list(T1)]
;Purpose        : gets a list and a number pos and returns a new list whose elements are the first pos elements of the lists.
                   if the list is shoerter than the pos then return the list.
; Pre-condition : true
; Tests         : (take (list 1 2 3) 2) â†’ '(1 2)
;---------------------------------------------------------------------------------

;---------------------------------------------------------------------------------
;Signature      : take-map(lst,func,pos)
;Type           : [(int->Boolean)*list(T1)-> list(T1)]
;Purpose        : returns a new list whose elements are the first pos elements mapped by func
; Pre-condition : true
; Tests         : (take-map (list 1 2 3) (lambda (x) (* x x)) 2) â†’ '(1 4)
;---------------------------------------------------------------------------------
;---------------------------------------------------------------------------------
;Signature      : take-filter(lst pred pos)
;Type           : [(T1->Boolean)*List(T1)*(int->boolean)-> list(T1)]
;Purpose        : returns a new list whose elements are the first pos elements of the list that satisfy the pred.
; Pre-condition : true
; Tests         : (take-filter (list 1 2 3) (lambda (x) (> x 3)) 2) â†’ '()
;---------------------------------------------------------------------------------
;---------------------------------------------------------------------------------
;Signature      : sub-size(lst  size)
;Type           : [(int->Boolean)*list(T1)-> list(T1)]
;Purpose        : returns a new list of all the sublists of list of length size
; Pre-condition : true
; Tests         : (sub-size (list 1 2 3) 3) â†’ '((1 2 3))
;---------------------------------------------------------------------------------
;---------------------------------------------------------------------------------
;Signature      : sub-size-map(lst func size)
;Type           : [(int->Boolean)*list(T1)-> list(T1)]
;Purpose        : returns a new list of all the sublists of ğ‘™ğ‘–ğ‘ ğ‘¡ of length ğ‘ ğ‘–ğ‘§ğ‘’ that all their elements are mapped by ğ‘“ğ‘¢ğ‘›ğ‘.
; Pre-condition : true
; Tests         : (sub-size-map '() 0 (lambda (x) (+ x 1))) â†’ '(())
;---------------------------------------------------------------------------------
;---------------------------------------------------------------------------------
;Signature      : root(tree)
;Type           : [list(T) -> T]
;Purpose        : gets a list representing a tree and returns the value of the root
; Pre-condition : true
; Tests         : (root '(1 (#t 3 #t) 2) #t) â†’ 1
;---------------------------------------------------------------------------------
;---------------------------------------------------------------------------------
;Signature      : left(tree)
;Type           : [list(T) -> list(T)]
;Purpose        : gets a list representing a tree and returns the subtree of the left son, or an empty list if there is no left son.
; Pre-condition : true
; Tests         : (left '(1 (#t 3 #t) 2) #t) â†’ (#t 3 #t) 
;---------------------------------------------------------------------------------
;---------------------------------------------------------------------------------
;Signature      : right(tree)
;Type           : [list(T) -> list(T)]
;Purpose        : gets a list representing a tree and returns the subtree of the right son, or an empty list if there is no left son.
; Pre-condition : true
; Tests         : (right '(1 (#t 3 #t) 2) #t) â†’ 2 
;---------------------------------------------------------------------------------
;---------------------------------------------------------------------------------
;Signature      : count-nodes(tree val)
;Type           : [list(T)*int -> int]
;Purpose        : given a list representing a ğ‘¡ğ‘Ÿğ‘’ğ‘’ and an atomic ğ‘£ğ‘ğ‘™, returns the number of nodes whose value is equal to ğ‘£ğ‘ğ‘™.
; Pre-condition : true
; Tests         : (count-node '(1 (#t 3 #t) 2) #t) â†’ 2
;---------------------------------------------------------------------------------
;---------------------------------------------------------------------------------
;Signature      : mirror-tree(tree  )
;Type           : [list(T) -> list(T)]
;Purpose        : given a list representing a ğ‘¡ğ‘Ÿğ‘’ğ‘’, returns the mirrored tree.
; Pre-condition : true
; Tests         : (mirror-tree '(1 (#t 3 4) 2)) -> '(1 2 (#t 4 3))
;---------------------------------------------------------------------------------
;Signature      : make-ok(val)
;Type           : [val -> OK(val)]
;Purpose        : gets a value and returns an ok structure for the ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ of type result.
; Pre-condition : true
; Tests         : (define ok (make-ok 1))
;---------------------------------------------------------------------------------
;Signature      : make-error(message)
;Type           : [message -> EROR(message)]
;Purpose        : gets an error ğ‘šğ‘’ğ‘ ğ‘ ğ‘ğ‘”ğ‘’ and returns an error structure for the ğ‘šğ‘’ğ‘ ğ‘ ğ‘ğ‘”ğ‘’ of type result.
; Pre-condition : true
; Tests         : (define error (make-error â€œsome error messageâ€))
;---------------------------------------------------------------------------------
;Signature      : ok?(pred)
;Type           : [pred -> Booolean]
;Purpose        : type predicate for ğ‘œğ‘˜.
; Pre-condition : true
; Tests         : (ok? ok) â†’ #t
;---------------------------------------------------------------------------------
;Signature      : error?(pred)
;Type           : [pred -> Booolean]
;Purpose        : type predicate for error.
; Pre-condition : true
; Tests         : (error? ok) â†’ #f
;---------------------------------------------------------------------------------
;Signature      : result?(pred)
;Type           : [pred -> Booolean]
;Purpose        : type predicate for result.
; Pre-condition : true
; Tests         : (result? ok) â†’ #t
;---------------------------------------------------------------------------------
;Signature      : result(val)
;Type           : [val -> int]
;Purpose        : gets a ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ structure and returns the value it represents, or the error 
                  message for error. If the given result is not a result, return an error structure with the
                  message â€œError: not a resultâ€
; Pre-condition : true
; Tests         : (result->val ok) â†’ 1
;---------------------------------------------------------------------------------
;Signature      : bind(func)
;Type           : [function -> function]
;Purpose        : bind which given a function ğ‘“ğ‘¢ğ‘›ğ‘ from a non-result to
                  result, returns a new function which given a result, returns the activation of ğ‘“ğ‘¢ğ‘›ğ‘ on its
                  value or an error structure accordingly.
; Pre-condition : true
; Tests         : (define inc-result (bind (lambda (x) (make-ok (+ x 1)))))
;---------------------------------------------------------------------------------





